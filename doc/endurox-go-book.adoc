The book of the Enduro/X for Golang
===================================
Madars Vitolins
v1.0, 2016-11:
	Initial draft
:doctype: book

== Introduction

This module is set of objects that are binded to Enduro/X C based framework. 
Enduro/X by it self is middleware that uses operating system kernel queues for 
doing high performance inter-process communication. The middleware functionality 
is in the heart of the Enduro/X. Other functionality that comes in the package
is application server, which boots up the processes, monitors them (restarts is
they become dead), detects stalled services.

The processes in Enduro/X are split into to categories:

1. Client processes

2. Server processes

The client processes might be a stand alone process (executables running in system)
or it can be controlled by Enduro/X's Client Process Monitor (cpmsrv). Which gives
administrator nice interface for configuring/starting/stopping the clients.

The server processes are ones that are started by Enduro/X local daemon process
called 'ndrxd'. The server process have inside a thread which conforms the XATMI
server process workflow. At the startup the init function is called. Then threads
goes into waiting on message dispatches (waits on Posix queues). 

Once the application server is going for shutdown or administrator is about to
shutdown single server, then XATMI server process is notified of this action
and server process can gracefully do the de-init and shutdown. The uninit callback
is send to server process while doing shutdown.


== API Model

The Enduro/X API object oriented where the main Enduro/X objects are held into Go
structures. List of methods are binded to the structures. Here is the main model
of the Go API:

image:images/class_diagram.png[caption="Figure 1: ", title="API Model", alt="enduro/x Golang API model"]


== Enduro/X Go features

This section list the features which are supported by Go module.

- XATMI Server process

- XATMI Client process

- Distributed transaction processing (currently with patched go-oci8, which can 
be downloaded here: https://github.com/endurox-dev/go-oci8

- Debug logging infrastructure 

- Persistent queues

- Buffers: UBF, JSON, String, Binary array (carray)

- Load balancing

- High availability

== Constants
This chapter describes constants used by Enduro/X module. This includes error codes
and flags.


=== ATMI Context method binary OR'able flags

*TPNOBLOCK* (0x00000001) - Do not block the operation (don't wait for reply or 
resource availability).

*TPSIGRSTRT* (0x00000002) - Restart the the system call if interrupted.

*TPNOREPLY* (0x00000004) - Make asynchronous call, do not wait for reply. 

*TPNOTRAN* (0x00000008) - Do not run in transaction mode.

*TPTRAN* (0x00000010) - Reserved for future use.

*TPNOTIME* (0x00000020) - Do not interrupt the call by timeout condition.

*TPGETANY* (0x00000080) - Get any call reply.

*TPNOCHANGE* (0x00000100) - Do not change buffer format. If reply on tpcall()
receives other buffer format than specified in call and this flag is set, then
error will be generated.

*TPCONV* (0x00000400) - Reserved for future use.

*TPSENDONLY* (0x00000800) - Enter in sending mode during conversational IPC.

*TPRECVONLY* (0x00001000) - Enter in receiving mode during conversational IPC.

*TPTRANSUSPEND* (0x00040000) - Suspend current transaction.


=== ATMI buffer size
Current Enduro/X version support maximum buffer size of 64KB. The constant is
defined for that:

*ATMI_MSG_MAX_SIZE* (65536) - Max ATMI message size.

This is subject of change in future. It might that dynamic number (configurable)
will be available.

=== ATMI Error codes (returned by ATMIError interface)

This chapter lists the error codes returned by ATMI calls.

*TPMINVAL* (0) - No error.

*TPEABORT* (1) - Transaction was marked for abort.

*TPEBADDESC* (2) - Bad call descriptor.

*TPEBLOCK* (3) - Reserved for future use.

*TPEINVAL* (4) - Invalid value passed to function.

*TPELIMIT* (5) - System limits exceeded (max queues or call descriptors open).

*TPENOENT* (6) - No Entry (XATMI service or other resources).

*TPEOS* (7) - Operating system error occurred.

*TPEPERM* (8) - Reserved for future use.

*TPEPROTO* (9) - Protocol error. Invocation of XATMI functions in invalid order.

*TPESVCERR* (10) - Server error. XATMI server died during processing.

*TPESVCFAIL* (11) - Application level error at service.

*TPESYSTEM* (12) - System error.

*TPETIME* (13) - Time-out condition.

*TPETRAN* (14) - Transaction error.

*TPGOTSIG* (15) - Reserved for future use.

*TPERMERR* (16) - Resource manager error (used for distributed transactions processing)

*TPEITYPE* (17) - Reserved for future use. 

*TPEOTYPE* (18) - Invalid output type.

*TPERELEASE* (19) - Reserved for future use. 

*TPEHAZARD* (20) - Hazardous condition occurred. Transaction is partially 
committed and/or abort.

*TPEHEURISTIC* (21) - Heuristic condition occurred. Transaction is partially 
committed and/or abort.

*TPEEVENT* (22) - Event notification received for conversational IPC session.

*TPEMATCH* (23) - Did not match given identifier.

*TPEDIAGNOSTIC* (24) - Additional information is returned in diagnostics field 
(used by persistent queues API).

*TPEMIB* (25) - Reserved for future use. 

*TPINITFAIL* (30) - Reserved for future use. 

*TPMAXVAL* (31) - Maximum error code.


=== Return values for tpcall()/tpreturn()

Values for rval in tpreturn:


*TPFAIL* (0x0001) - Application level error occurred, returns tpcall() gives *TPESVCFAIL*
as error.

*TPSUCCESS* (0x0002) - Service succeeded.



=== Flags Persistent queue functions, used for TPQCTL.flags

*TPNOFLAGS* (0x00000) - No flags used.

*TPQCORRID* (0x00001) - Set/get correlation id (on set TPQCTL.corrid must
be specified.

*TPQFAILUREQ* (0x00002) - Set/get failure queue. On set TPQCTL.failurequeue must
be specified.

*TPQBEFOREMSGID* (0x00004) - RFU, enqueue before message id.

*TPQGETBYMSGIDOLD* (0x00008) - RFU, deprecated.

*TPQMSGID* (0x00010) - Get msgid of enqueued/dequeued message.

*TPQPRIORITY* (0x00020) - Set/get message priority.

*TPQTOP* (0x00040) - RFU, enqueue at queue top.

*TPQWAIT* (0x00080) - RFU, wait for dequeuing.

*TPQREPLYQ* (0x00100) - Set/get reply queue.

*TPQTIME_ABS* (0x00200) - RFU, set absolute time.

*TPQTIME_REL* (0x00400) - RFU, set absolute time.

*TPQGETBYCORRIDOLD* (0x00800) - RFU.

*TPQPEEK* (0x01000) - Peek the message from queue. Do not dequeue it permanently.

*TPQDELIVERYQOS* (0x02000) - RFU, delivery quality of service.

*TPQREPLYQOS* (0x04000) -  RFU, reply message quality of service.

*TPQEXPTIME_ABS* (0x08000) -  RFU, absolute expiration time.

*TPQEXPTIME_REL* (0x10000) -  RFU, relative expiration time.

*TPQEXPTIME_NONE* (0x20000) -  RFU, never expire.

*TPQGETBYMSGID* (0x40008) -  Dequeue by msgid.

*TPQGETBYCORRID* (0x80800) - Dequeue by corrid.

*TPQASYNC* (0x100000) - Async complete. Complete the disk based transaction asynchronously.


=== Other persistent queue sub-system constants

*TMMSGIDLEN* (32) - Message id (number of bytes). All bytes significant.

*TMCORRIDLEN* (32) - Correlator id (number of bytes). All bytes significant.

*TMQNAMELEN* (15) - Max queue name length.

*NDRX_MAX_ID_SIZE* (96) - Client ID length
	

=== Diagnostic codes for persistent queues

For persistent queue sub-system which are used by TpEnqueue(3) and TpDequeue(3)
there are special control structure used named *TPQCTL* it contains field 
*TPQCTL.diagnostic* which return diagnostic code. This field is filled in case if
*ATMIError.Code()* is set to TPEDIAGNOSTIC. Note that additional error message is
provided into *TPQCTL.diagmsg*

*QMEINVAL* (-1) - Invalid value passed to function.

*QMEBADRMID* (-2) - RFU.

*QMENOTOPEN* (-3) - RFU.

*QMETRAN* (-4) - RFU.

*QMEBADMSGID* (-5) - RFU.

*QMESYSTEM* (-6) - System error occurred. More info in logs.

*QMEOS* (-7) - Operating system error occurred. More info in logs.

*QMEABORTED* (-8) - RFU.

*QMENOTA* (-8) - RFU.

*QMEPROTO* (-9) - RFU.

*QMEBADQUEUE* (-10) - RFU.

*QMENOMSG* (-11) - No message found.

*QMEINUSE* (-12) - RFU.

*QMENOSPACE* (-13) - RFU.

*QMERELEASE* (-14) - RFU.

*QMEINVHANDLE* (-15) - RFU.

*QMESHARE* (-16) - RFU.


=== Enduro/X standard library error codes
List of error codes that can be returned by NSTDError interface:

*NEINVALINI* (1) - Invalid INI file

*NEMALLOC* (2) - Malloc failed 

*NEUNIX* (3) - Unix error occurred

*NEINVAL* (4) - Invalid value passed to function

*NESYSTEM* (5) - System failure

*NEMANDATORY* (6) - Mandatory field is missing

*NEFORMAT* (7) - Format error 


=== Unified Buffer Format (UBF) library error codes

These error codes are returned by UBFError interface:

*BMINVAL* (0) - No error.

*BERFU0* (1) - Reserved for future use.

*BALIGNERR* (2) - Invalid UBF buffer.

*BNOTFLD* (3) - Buffer not fielded/invalid UBF buffer.

*BNOSPACE* (4) - No space in buffer left.

*BNOTPRES* (5) - Field not present.

*BBADFLD* (6) - Bad field id.

*BTYPERR* (7) - Invalid field type.

*BEUNIX* (8) - Unix error.

*BBADNAME* (9) - Bad field name.

*BMALLOC* (10) - Malloc failed.

*BSYNTAX* (11) - Syntax error for boolean expression.

*BFTOPEN* (12) - Failed to open field table (ubftab).

*BFTSYNTAX* (13) - Field table (ubftab) syntax error.

*BEINVAL* (14) - Invalid value passed to function.

*BERFU1* (15) - Reserved for future use.

*BERFU2* (16) - Reserved for future use.

*BERFU3* (17) - Reserved for future use.

*BERFU4* (18) - Reserved for future use.

*BERFU5* (19) - Reserved for future use.

*BERFU6* (20) - Reserved for future use.

*BERFU7* (21) - Reserved for future use.

*BERFU8* (22) - Reserved for future use.

*BMAXVAL* (22) - Maximum error code;


=== UBF field types

This chapter lists field types (C level) used by UBF:

*BFLD_MIN* (0) - Minimum field type

*BFLD_SHORT* (0) - C Short type

*BFLD_LONG* (1) -C Long type

*BFLD_CHAR* (2) - C Chart type (single byte)

*BFLD_FLOAT* (3) - C Float type

*BFLD_DOUBLE* (4) - C Double type

*BFLD_STRING* (5) - String type

*BFLD_CARRAY* (6) - Byte array type

*BFLD_MAX* (6) - Maximum field type


=== UBF reserved field IDs

*BBADFLDID* (0) - Bad field id, used as terminator Bproj() and other calls.

*BFIRSTFLDID* (0) - First field id, used indicator for Bnext() to iterate through
the buffer.

=== Log levels
Enduro/X provides logging API (see ATMICtx.TpLog() and related functions).
Following debug levels are supported:

*LOG_ALWAYS* (1) - Fatal error. Logs always.

*LOG_ERROR* (2) - Error message.

*LOG_WARN* (3) - Warning message.

*LOG_INFO* (4) - informational message.

*LOG_DEBUG* (5) - Debug message.

*LOG_DUMP* (6) - Very detailed debug with full dumps.


=== Log Facilities

Enduro/X logging can be configured for different logging sources which includes
Enduro/X debugging it self (provides separation for base ATMI (*NDRX*), Unified 
Buffer Format (*UBF*) functions). The user logging are configured under the *TP* facility.

User logging can be associated in following levels:

- Per process;

- Per thread (for Go it is Context).

- Per request (associate with Context, i.e. if thread logging enabled, then it can be
promoted to request logging by *ATMICtx.TpLogSetReqFile()*).

*LOG_FACILITY_NDRX* (0x00001) - Settings for ATMI logging.

*LOG_FACILITY_UBF* (0x00002) - Settings for UBF logging.

*LOG_FACILITY_TP* (0x00004) - Settings for TP logging.

*LOG_FACILITY_TP_THREAD* (0x00008) - Settings for TP, thread based logging.

*LOG_FACILITY_TP_REQUEST* (0x00010) - Request logging, thread based.


== Structures

This section lists the exported (public) structures provided by Endurox-Go module.

[cols="h,5a",options="header"]
|===
|Struct/interface
|Description

|TPTRANID
|Transaction identifier

|ATMICtx
|ATMI Context object

|TPSRVCTXDATA
|Server Context data used for copying request context from one Context to another

|TPEVCTL
|Event control structure (see bellow for more information)

|TPQCTL
|Queue control structure (see bellow for more information)

|ATMIBuf
|ATMI buffer object (abstract one)

|TypedBuffer
|Interface to ATMIBuf. Provides getter for getting raw buffer handler

|TypedUBF
|Interface to UBF buffer.

|TypedCarray
|Interface to byte array buffer.

|TypedString
|Interface to String buffer.

|TypedJSON
|Interface to JSON buffer.

|ATMIError
|ATMI Error interface. Provides Error(), Code(), Message() methods.

|UBFError
|UBF library error interface. Provides Error(), Code(), Message() methods.

|NSTDError
|Stndard library error interface. Provides Error(), Code(), Message() methods.

|TPSVCINFO
|XATMI service call descriptor, provided to called service as parameters.
(see bellow for more information)
|===

=== Event control structure - TPEVCTL

--------------------------------------------------------------------------------
/*
 * Event controll struct
 */
type TPEVCTL struct {
	flags int64
	name1 string
	name2 string
}
--------------------------------------------------------------------------------

TPEVCTL is used by ATMICtx.TpSubscribe() function. TPEVCTL structure contains following fields:

- *flags* int64 - can be set to: TPEVSERVICE, TPEVPERSIST

- *name1* string - Event expression

- *name2* string - RFU.

See tpsubscribe(3) C manpage.


=== Queue operations control structure - TPQCTL

Queue control structure is self explanatory.

--------------------------------------------------------------------------------
/*
 * Queue control structure
 */
type TPQCTL struct {
	flags        int64             /* indicates which of the values are set */
	deq_time     int64             /* RFU, absolute/relative  time for dequeuing */
	priority     int64             /* RFU, enqueue priority */
	diagnostic   int64             /* indicates reason for failure */
	diagmsg      string            /* diagnostic message */
	msgid        [TMMSGIDLEN]byte  /* id of message before which to queue */
	corrid       [TMCORRIDLEN]byte /* correlation id used to identify message */
	replyqueue   string            /* queue name for reply message */
	failurequeue string            /* queue name for failure message */
	cltid        string            /* client identifier for originating client */
	urcode       int64             /* RFU, application user-return code */
	appkey       int64             /* RFU, application authentication client key */
	delivery_qos int64             /* RFU, delivery quality of service  */
	reply_qos    int64             /* RFU, reply message quality of service  */
	exp_time     int64             /* RFU, expiration time  */
}
--------------------------------------------------------------------------------


=== Incoming service call information structure - TPSVCINFO
When XATMI server receives request, it receives a control structure with information
about sender and meta data about service which actually is invoked. For example:


--------------------------------------------------------------------------------

package main

import (
        "atmi"
        "fmt"
        "os"
)

//Service func
//Here svc contains the caller infos
func TESTSVC(ac *atmi.ATMICtx, svc *atmi.TPSVCINFO) {

        ac.TpReturn(atmi.TPSUCCESS, 0, &ub, 0)

}

//Server boot/init
func Init(ac *atmi.ATMICtx) int {

        //Advertize TESTSVC
        if err := ac.TpAdvertise("TESTSVC", "TESTSVC", TESTSVC); err != nil {
                fmt.Println(err)
                return atmi.FAIL
        }

        return atmi.SUCCEED
}

//Server shutdown
func Uninit(ac *atmi.ATMICtx) {
        fmt.Println("Server shutting down...")
}


//Server main
func main() {
        //Have some context
        ac, err := atmi.NewATMICtx()

        if nil != err {
                fmt.Errorf("Failed to allocate cotnext!", err)
                os.Exit(atmi.FAIL)
        } else {
                //Run as server
                ac.TpRun(Init, Uninit)
        }
}

--------------------------------------------------------------------------------


TPSVCINFO is defined as follows (with explanatory comments):

--------------------------------------------------------------------------------
//Servic call info
type TPSVCINFO struct {
	Name   string   /* Service name */
	Data   ATMIBuf  /* Buffer type */
	Flags  int64    /* Flags used for service invation */
	Cd     int      /* Call descriptor (generated by client) */
	Cltid  string   /* Client ID string - full client queue name */
	Appkey int64    /* RFU */
	Fname  string   /* Function name invoked (set at TpAdvertise second param) */
	Ctx    *ATMICtx /* ATMI Server Context */
}
--------------------------------------------------------------------------------


The TPSVCINFO.Ctx basically is the same context passed into service function as
first argument.

== API

Section lists API functions in following levels:

- ATMI package (global functions)

- ATMI Context functions

- ATMI Error functions

- UBF functions

[[gen_doc-start]]
[[gen_doc-stop]]

== Typical server process
This section gives an example of typical Enduro/X XATMI server written in Google
Go language. This sample will advertise two services which will make a string buffer
uppercase (the service name will be TOUPPER) and another service which make a string
lower case (service name TOLOWER).

--------------------------------------------------------------------------------
package main

import (
	"atmi"
	"fmt"
	"os"
)

const (
	SUCCEED = 0
	FAIL    = -1
)

func TOUPPER(ac *atmi.ATMICtx, svc *atmi.TPSVCINFO) {

	ret := SUCCEED

	//Get Typed String Handler
	s, _ := ac.CastToString(&svc.Data)

	// Change the buffer
	s.SetString(strings.ToUpper(s.GetString()))
	
	// Send back the response
	ac.TpReturn(atmi.TPSUCCESS, 0, &s, 0)
	
	return
}

func TOLOWER(ac *atmi.ATMICtx, svc *atmi.TPSVCINFO) {

	ret := SUCCEED

	//Get Typed String Handler
	s, _ := ac.CastToString(&svc.Data)

	// Change the buffer
	s.SetString(strings.ToLower(s.GetString()))
	
	// Send back the response
	ac.TpReturn(atmi.TPSUCCESS, 0, &s, 0)
	
	return
}


//Server init
func Init(ac *atmi.ATMICtx) int {

	//Advertize TOUPPER
	if err := ac.TpAdvertise("TOUPPER", "TOUPPER", TOUPPER); err != nil {
		fmt.Println(err)
		return atmi.FAIL
	}
	
	//Advertize TOLOWER
	if err := ac.TpAdvertise("TOLOWER", "TOLOWER", TOLOWER); err != nil {
		fmt.Println(err)
		return atmi.FAIL
	}

	return atmi.SUCCEED
}

//Server shutdown
func Uninit(ac *atmi.ATMICtx) {
	fmt.Println("Server shutting down...")
}

//Executable main entry point
func main() {
	//Have some context
	ac, err := atmi.NewATMICtx()

	if nil != err {
		fmt.Errorf("Failed to allocate cotnext!", err)
		os.Exit(atmi.FAIL)
	} else {
		//Run as server
		ac.TpRun(Init, Uninit)
		
		//Kill the ATMI context
		ac.FreeATMICtx()
	}
}
--------------------------------------------------------------------------------

Note that for simplicity some error handling for service functions are missing.

== Typical client process
This section will give us an example how would client process look for above example,
we will invoke both service to TOUPPER and TOLOWER.

--------------------------------------------------------------------------------
package main

import (
	"atmi"
	"fmt"
	"os"
)

const (
	SUCCEED = 0
	FAIL    = -1
)

//Binary main entry
func main() {

	ret := SUCCEED
	var ac *atmi.ATMICtx
	var err atmi.ATMIError
	//Return to the caller (kind of destructor..)
	defer func() {
		if nil != ac {
			ac.TpTerm()
			ac.FreeATMICtx() // Kill the context
		}
		os.Exit(ret)
	}()

	ac, err = atmi.NewATMICtx()

	if nil != err {
		fmt.Errorf("Failed to allocate cotnext!", err)
		ret = FAIL
		return
	}

	buf, err := ac.NewString("hello world")

	if err != nil {
		ac.TpLogError("ATMI Error %d:[%s]\n", err.Code(), err.Message())
		ret = FAIL
		return
	}

	//Call the server
	if _, err := ac.TpCall("TOUPPER", buf, 0); nil != err {
		ac.TpLogError("ATMI Error %d:[%s]\n", err.Code(), err.Message())
		ret = FAIL
		return
	}

	//Will print "HELLO WORLD"
	fmt.Printf("Got response: [%s]\n", buf.GetString())
	
	//Now call to lower with same buffer
	
	if _, err := ac.TpCall("TOLOWER", buf, 0); nil != err {
		ac.TpLogError("ATMI Error %d:[%s]\n", err.Code(), err.Message())
		ret = FAIL
		return
	}

	//Will print "hello world"
	fmt.Printf("Got response: [%s]\n", buf.GetString())
	
	return
}
--------------------------------------------------------------------------------


== Distributed transaction processing

Distributed transaction currently is supported only for Oracle OCI8 driver which is
binded to Go, the package is available here: https://github.com/endurox-dev/go-oci8

One note must be told, that distributed transaction work according to XA API standard
which sets that transaction is associated with current operating system thread.

Enduro/X acknowledges this fact and provides API call for associating ATMI Context
object with current thread. As Golang Goroutines can be user-space re-scheduled,
thus before associating ATMI Context with OS Thread, you need to *runtime.LockOSThread()* and
then *ac.AssocThreadWithCtx()*.

For example:


--------------------------------------------------------------------------------
func MKCUST(ac *atmi.ATMICtx, svc *atmi.TPSVCINFO) {

        runtime.LockOSThread()
        ac.AssocThreadWithCtx()
        
        // Do the DB works in global transaction
        
        ac.DisassocThreadFromCtx()
        runtime.UnlockOSThread()
        
        ac.TpReturn(atmi.TPSUCCESS, 0, &ub, 0)
        
        return
}
--------------------------------------------------------------------------------



== Conclusions

For more tails you may see the tests folder which contains following tests:

- *01_basic_ubf_call* - Sample client/server app with UBF buffer.

- *02_basic_string_call* - Sample client/server app with String buffer.

- *03_basic_carray_call* - Sample client/server app with binary byte buffer.

- *04_distributed_transaction* - Sample client/server app with Oracle DB distributed transaction.

- *05_basic_json_call* - Sample client/server app with JSON buffer.

- *06_ubf_marshal* - Client process doing Marshal/Unmarshal of UBF buffer to structure.

- *07_basic_durable_queue* - Works with durable queue.

- *08_logging* - User logging tests.


For more details read on: http://www.endurox.org/dokuwiki
The base Enduro/X documentation is valid, as Enduro/X ASG is wrapping in the C
libraries.


:numbered!:

[bibliography]
Additional documentation 
------------------------
This section lists additional related documents.

[bibliography]
.Resources
- [[[EX_DEVGUIDE]]] Enduro/X Internal Developer Guide.


////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////
